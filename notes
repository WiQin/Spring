spring framework
1.背景介绍
代码的三层架构：
    实现高内聚，低耦合
        web：表示层，与用户交互，依赖service,手动创建对象
        service：业务逻辑层，处理业务逻辑
        dao：数据访问层，与数据库交互

        上层对下层的调用：面向接口/抽象编程
        下层对上层的真正服务提供：实现类

        模块和模块之间，对象和对象之间，手动在代码中书写，建立关系。

spring：尽量解耦，管理需要管理的对象，包括对象的创建，初始化，装配(维护对象与对象之间的关系)，销毁（生命周期），不需要在代码中
        事务管理

IOC :对象创建
AOP :事务管理

2.相关概念
    2.1轻量级容器
    容器：spring容器帮我们管理业务逻辑层，里边有很多业务逻辑对象，有对象就有对象的生命周期的管理（创建，销毁）。
    轻量级：容器给予的业务逻辑对象多少种服务？spring给用户提供的服务完全有用户自己决定，spring想用什么服务自己开启使用。但是重量级的都是只要你用就把所有的服务都给你，不能自己定制。
    特点：应用模块之间耦合度小，组件都是可重用的，都是各自打包的

    why spring？
    	1）动态解藕，方便开发，面向接口设计
    	通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用
    	2）方便程序的测试
    	3）降低Java EE API的使用难度
    	Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个简单的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。
    	4）方便集成各种优秀框架
    	Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts,Hibernate、Hessian、Quartz）等的直接支持。
    	5）AOP编程的支持
    	通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。
    	6）声明式事务的支持
    	在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。
    	7）spring是一个模块化的项目,可以根据自己的需要定制功能模块

    	spring的核心宗旨:简化企业级应用开发，同时给复杂问题提供强大的、非侵入性解决方案
    	一站式的解决方案

3.核心组件
    （1）、Spring Core(IOC) 核心容器，提供组件的创建、装备、销毁（管理对象）
    （2）、Spring Context Spring上下文，是一个接口ApplicationContext（继承自BeanFactory接口）的实现
    （3）、Spring Web容器，web应用上下文，是webApplicationContext接口的实现
    （4）、Spring DAO容器，是SpringDAO 支持模块，是为了简化DAO的使用
    （5）、Spring ORM
    （6）、Spring AOP ，对AOP编程支持的模块
    （7）、Spring MVC，类似于Spring表示层的一个框架

4.Spring IoC
    Inversion of Control:控制反转
    一种说法：对象之间的依赖关系，由容器在运行时依据配置文件动态的建立
    另一种说法：对象的控制器转移了，转到外部容器了，避免了代码的纠缠，代码更容易被维护，模板之间的耦合性降低，容易测试

    IoC 控制反转意味着将你设计好的类交给容器去控制,而不是在类的内部进行控制,即控制权由应用代码中转到了外部容器

    IoC:包括两部分内容
          DI:Dependency Injection依赖注入,组件不做定位查询,只提供相应方法,由容器创建对象,并调用相应方法设置所需对象需要的组件(要求掌握)
            A a = new A();  B b = new B();   a.setXXX(b)    ---由spring实现
          DL:Dependency Loopup依赖查找,容器创建对象并提供回调接口和上下文环境给组件,需要时通过接口从容器中查找对象(理解即可)   (之后会见到很多XxxxAware的接口)

    org.springframework.beans包和org.springframework.context包是IOC容器的基础包

5.Spring IoC 核心api
    5.1BeanFactory接口和容器
    BeanFactory是Spring中Bean容器,IoC的核心接口,主要用于处理Bean(可重用“组件（对象）”)的初始化和配置,建立对象间的依赖关系
    定义了如下方法:
       Object getBean(String name) //根据指定名称返回一个Bean实例
    在Spring中,同一Spring容器中的bean默认情况下是Singleton(单例).

    5.2ApplicationContext接口
    该接口继承于BeanFactory,增强了BeanFactory,提供了事务处理AOP,国际化,事件传递

    所以在代码中我们一般会使用ApplicationContext接口,以及这个接口相应的实现类来创建spring的容器对象。
    例如:
    String path = "com/ioc/set/set.xml";
    ApplicationContext container = new ClassPathXmlApplicationContext(path);

6.配置文件
    Spring通过读取配置文件中的数据来对应用中各个对象进行实例化,配置以及组装,通常使用XML文件来作为配置文件。
       XML基本结构如下:
    	<?xml version="1.0" encoding="UTF-8"?>
    	<beans xmlns="http://www.springframework.org/schema/beans"
    		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    		xmlns:context="http://www.springframework.org/schema/context"
    		xsi:schemaLocation="http://www.springframework.org/schema/beans
    		   http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
    		   http://www.springframework.org/schema/context
    		   http://www.springframework.org/schema/context/spring-context-3.2.xsd">

    	</beans>

    这个文件的头部声明可以在下载的spring文档中的示例找到.注意这里面用到了俩个schema文件(.xsd文件),就是spring-beans-3.2.xsd和spring-context-3.2.xsd,这俩个文件在下载的spring文档中也是可以找到的.我们在Eclipse中把xml文件和schema文件关联后,在这个xml中就可以有智能提示了。还有一点需要注意,将来我们这xml中再引入另外的schema文件后在配置的时候就可以智能提示出新的配置内容,spring是又很多模块组成的,我们需要什么功能的配置标签就需要引入对应的schema文件,从而获得智能提示,同时也能帮我们验证配置的正确性

问题1：如何通过[读取]配置文件[一个或多个对象的相关配置]创建对象[需要管理的对象]并建立对象与对象的依赖关系[ioc--DI]?

    1.1读取配置文件 dom4j
    1.2获取根标签beans,获取bean(list存)
    1.3获取bean标签的name（beanName）,class（通过class创建对象Object）
        Map方式存  map<beanName,Object>
    1.4 property  name--通过name得到setXXX方法（反射）   ref--map.get("stu"),获取关联对象
        method.invoke(t,stu)

7.IOC注入
7.1 set方式注入
    可以注入的内容有:
          A、基本类型（8中基本类型+字符串）的装配
          B、对象类型的装配
          C、集合的装配
     A、基本类型的装配
           方式: 配置元素<value/>
           例子：
     	public class HelloBean {
     		private String name;
     		private int age;
     		public String sayHello(){
     			return "hello "+name +",your age is" + age;
     		}
     		.............
     	}
     	配置文件set.xml
     	<bean id="helloBean" class="ioc.HelloBean">
     		<property name="name">
     			<value>tom</value>
     		</property>
     			<property name="age" value="20">
     		</property>
     	</bean>
     	<!--
     	id是Bean的唯一标识，要求在整个配置文件中要唯一，也可使用name属性，bean标签里面的id和name属性都可以用来标识这个配置的对象,
     	但是id会帮我们检查给对象起的名字是否规范(名字不能重复、不能用数字开头、不能有空格等等),如果检查出来了那么就会报错。name属性不会帮检查这些东西(某些版本)。
     	 -->
     	<!--property 对于所有用set方式来注入的必须使用该标签-->
     	<!--value    是对以基本类型，都用value(标签/属性)来注入，可以实现自动的数据类型转换-->

     	测试类：
     	   main:
     		ApplicationContext ac =
     			new ClassPathXmlApplicationContext("set.xml");
     		//获取容器的一个实例
     		HelloBean hb = (HelloBean) ac.getBean("helloBean");
     		System.out.println(hb.sayHello());



     B、对象类型的装配
     	  （1）、<ref local=" "/> 用于涉及的对象的id在本配置文件中
     	  （2）、<ref bean=" "/>  用于涉及的对象的id不在本配置文件中
     	  （3）、使用property的ref属性引用

     	public class OtherBean {
     		private String str1;
     		public String getStr1() {
     			return str1;
     		}
     		public void setStr1(String str1) {
     			this.str1 = str1;
     		}
     		public String toString(){
     			return "OtherBean "+str1;
     		}
     	}

     	public class SomeBean {
     		private OtherBean ob;
     		public void printInfo(){
     			System.out.println("someBean "+ob);
     		}
     		public OtherBean getOb() {
     			return ob;
     		}
     		public void setOb(OtherBean ob) {
     			this.ob = ob;
     		}
     	}

     	配置applicationContext.xml
     	<bean id="someBean" class="ioc.SomeBean">
     		<property name="ob">
     			<ref bean="otherBean" />
     		</property>
     	</bean>

     	配置other.xml文件
     	<bean id="otherBean" class="ioc.OtherBean">
     		<property name="str1">
     			<value>hello</value>
     		</property>
     	</bean>

     	测试类：
     	main:
     		String[] path = {"ioc/applicationContext.xml","ioc/other.xml"};
     		ApplicationContext ac = new ClassPathXmlApplicationContext(path);
     		SomeBean sb = (SomeBean) ac.getBean("someBean");
     		sb.printInfo();


     C、集合的装配
     	方式：配置元素<list> <set> <map> <props>
     	public class SomeBean {
     		private List listProperty;
     		private Set setProperty;
     		private Map mapProperty;
     		private Properties<String,String> property;
     		public List getListProperty() {
     			return listProperty;
     		}
     		public void setListProperty(List listProperty) {
     			this.listProperty = listProperty;
     		}
     		public Set getSetProperty() {
     			return setProperty;
     		}
     		public void setSetProperty(Set setProperty) {
     			this.setProperty = setProperty;
     		}
     		public Map getMapProperty() {
     			return mapProperty;
     		}
     		public void setMapProperty(Map mapProperty) {
     			this.mapProperty = mapProperty;
     		}
     		public Properties getProperty() {
     			return property;
     		}
     		public void setProperty(Properties property) {
     			this.property = property;
     		}
     		public void printInfo(){
     			System.out.println("listProperty");
     			System.out.println(listProperty);
     			System.out.println("setProperty");
     			System.out.println(setProperty);
     			Set set = mapProperty.entrySet();
     			Iterator it = set.iterator();
     			while(it.hasNext()){
     				 Map.Entry entry = (Entry) it.next();
     				 System.out.println("Key " +entry.getKey() );
     				 System.out.println("value "+entry.getValue());
     			}
     			System.out.println("props: ");
     			Set set2 = property.entrySet();
     			Iterator it2 = set2.iterator();
     			while(it2.hasNext()){
     				Map.Entry entry= (Entry) it2.next();
     				System.out.println("key "+entry.getKey());
     				System.out.println("value "+entry.getValue());
     			}
     		}
     	}

     	applcationContext.xml的写法：
     	<bean id="someBean" class="ioc.SomeBean">
     		<property name="listProperty">
     			 <list>
     			    <value>list1</value>
     			    <value>list1</value>
     			    <value>list3</value>
     			 </list>
     		</property>
     		<property name="setProperty">
     			 <set>
     			    <value>set1</value>
     			    <value>set1</value>
     			    <value>set3</value>
     			 </set>
     		</property>
     		<property name="mapProperty">
     			 <map>
     			    <entry key="key1">
     				  <value>value1</value>
     			    </entry>
     			    <entry key="key2">
     				  <value>value2</value>
     			    </entry>
     			 </map>
     		</property>
     		<property name="property">
     		     <props>
     			  <prop key="key1">prop1</prop>
     			  <prop key="key2">prop2</prop>
     			  <prop key="key3">prop3</prop>
     		     </props>
     		</property>
     	</bean>

     	测试类：
     	main:
     		String path = "ioc/applicationContext.xml";
     		ApplicationContext  ac =
     			new ClassPathXmlApplicationContext(path);
     		SomeBean sb = (SomeBean) ac.getBean("someBean");
     		sb.printInfo();

7.2基于构造器注入
    方式: 配置<constructor-arg>元素
    在Bean中不用写set方法，但是要有相应的构造器

    构造器注入有两种形式 一个是根据参数类型 一个是根据参数位置的下标，起始索引为0
    <constructor-arg type="int" value="">
    <constructor-arg  index="0" value="">

    例如:
    	<bean name="student" class="com.briup.bean.Student">
    		<constructor-arg type="int" value="25">
    		</constructor-arg>

    		<constructor-arg type="java.lang.String" value="tom">
    		</constructor-arg>

    		<constructor-arg type="long" value="100">
    		</constructor-arg>

    	</bean>

    	或者:
    	<bean name="student" class="com.briup.bean.Student">
    		 <constructor-arg index="2">
    			<value>30</value>
    		 </constructor-arg>

    		 <constructor-arg index="0">
    			<value>200</value>
    		 </constructor-arg>

    		 <constructor-arg index="1">
    			<value>lily</value>
    		 </constructor-arg>
    	</bean>

7.3自动注入
    容器依照一些规则去装配bean中的一个属性
          注意:自动装配只对[对象类型]起作用，对基本类型不起作用.
          第一种情况:
          在beans标签中配置装载方式：default-autowire="byName"
          default-autowire="byName"
        		在根元素beans中加入这个属性,那么下面所有的bean都会
        		使用byName的方式进行自动注入,如果在下面的某一个bean
        		里面想使用其他的方式进行注入,可以用autowire=""属性进行
        		说明,或者某一个bean不想使用任何自动注入就使用autowire="no"

          第二种情况:
          在bean标签中指定配置方式
          autowire="byName":
        		spring容器会到当前的类中找property的名字,然后
        		再根据这个名字去spring容器中找有没有和这个property
        		名字相同的对象,有的话,就把这个对象当做参数放到
        		setXxxx这个方法里面注入进来.
        		注意:了解property指的类中的什么东西。

          autowire="byType":
        		spring容器会根据当前类中的set方法里面参数的类型,
        		去容器中找相匹配的对象,如果没找到就算了,如果找到
        		一个就注入进来,如果找到多个,那么就会报错了.

          autowire="constructor"
    		根据构造器的参数类型去匹配

7.4 继承:并不是oo的继承关系
          bean的定义的继承，指bean的配置可去继承
          abstract =
                      true 抽象化 代码中不能getBean获取其对象
                      false 默认

          parent = "父类bean的id/name"

        例子：
    	<bean name="student" class="com.briup.bean.Student">
    		<property name="name">
    			<value>zhangsan</value>
    		</property>
    	</bean>


    	<!--
    		abstract="true" 表示当前的配置是一个抽象的配置,
    		这时候我们在代码中就不能通过这个bean的名字teacher来
    		获得相应的对象了(和java中的抽象类不能直接new对象的道理一样)

    		但是我们可以在写一个配置去继承这个抽象的配置,当然即使当前
    		这个配置不是抽象的,也能够被继承(和java中继承一样)
    	-->

    	<bean name="teacher" class="com.briup.bean.Teacher" abstract="true">
    		<property name="student" ref="student"></property>
    	</bean>

    	<!--
    		parent="teacher" 表示当前配置是继承了另外一个名字叫
    		teacher的bean的配置,配置和配置的继承像java中的类和类
    		直接的继承一样,子类会把父类中的对象继承过来.
    		当然在子配置里面依然是可以覆盖父配置中已经写的配置信息.
    	-->

    	<bean name="t" parent="teacher">

    		<property name="id">
    			<value>11</value>
    		</property>

    		<property name="name">
    			<value>TeacherWang</value>
    		</property>
    	</bean>

8.bean对象的生命周期
    生命周期执行的过程如下：

    	1）spring对bean进行实例化,默认bean是单例
    	2）spring对bean进行依赖注入
    	3）如果bean实现了BeanNameAware接口，spring将bean的id传给setBeanName()方法
    	4）如果bean实现了BeanFactoryAware接口，spring将调用setBeanFactory方法,将BeanFactory实例传进来
    	5）如果bean实现了ApplicationContextAware()接口，spring将调用setApplicationContext()方法将应用上下文的引用传入
    	6) 如果bean实现了BeanPostProcessor接口，spring将调用它们的postProcessBeforeInitialization接口方法
    	7) 如果bean实现了InitializingBean接口，spring将调用它们的afterPropertiesSet接口方法,类似的如果bean使用了init-method属性声明了初始化方法,改方法也会被调用
    	8）如果bean实现了BeanPostProcessor接口,spring将调用它们的postProcessAfterInitialization接口方法
    	9）此时bean已经准备就绪,可以被应用程序使用了,他们将一直驻留在应用上下文中，直到该应用上下文被销毁
    	10）若bean实现了DisposableBean接口,spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用


    其实很多时候我们并不会真的去实现上面说描述的那些接口,那么下面我们就除去那些接口针对bean的单例和非单例来描述下bean的生命周期:

    	单例管理的对象:
    		1.默认情况下,spring在读取xml文件的时候,就会创建对象。
    		2.在创建的对象的时候(先调用构造器),会去调用init-method=".."
    		属性值中所指定的方法.
    		3.对象在被销毁的时候,会调用destroy-method="..."属性值中所指定的方法.(例如调用container.destroy()方法的时候)
    		4.lazy-init="true",可以让这个对象在第一次被访问的时候创建

    	非单例管理的对象:
    		1.spring读取xml文件的时候,不会创建对象.
    		2.在每一次访问这个对象的时候,spring容器都会创建这个对象,并且调用init-method=".."属性值中所指定的方法.
    		3.对象销毁的时候,spring容器不会帮我们调用任何方法,
    		因为是非单例,这个类型的对象有很多个,spring容器一旦把这个对象交给你之后,就不再管理这个对象了.

9.XML文件导入其他XML文件配置
    如果我们在spring框架中配置了多个xml文件,我们可以在读取配置文件的时候把这些xml文件一下全都读取,也可以只读一个总的xml文件,在这个总的xml文件中把其他的xml全都都导入进来。

    例如:
    	student.xml文件:
    	<bean name="student" class="com.briup.bean.Student">
    		<property name="id">
    			<value>25</value>
    		</property>
    	</bean>

    	teacher.xml文件:
    	<bean name="teacher" class="com.briup.bean.Teacher">
        	<property name="student" ref="student"></property>
    	</bean>

    	import.xml文件:
    	<import resource="teacher.xml"/>
    	<import resource="student.xml"/>

    	main:
    	String[] path = {"com/briup/ioc/imp/import.xml"};
    	ApplicationContext container =
    			new ClassPathXmlApplicationContext(path);

    	Teacher t = (Teacher) container.getBean("teacher");
    	System.out.println(t.getStudent());

10.创建bean实例的方式
      1) xml文件中有bean的配置,而且这个bean所对应的java类中存在一个无参构造器，那么这个时候spring容器就可以使用反射调用无参构造器来创建实例了(常规的方式)


      2) 通过工厂类获得实例(工厂类实现了接口FactoryBean<?>)
         注意spring中的PropertyPlaceholderConfigurer类的使用,在htmlsingle中直接搜索类名即可
         例如:
         工厂类实现指定接口并且实现接口中的三个抽象方法:
       public class ConnectionFactory implements FactoryBean<Connection>{
   		private String driver;
   		private String url;
   		private String username;
   		private String password;

   		@Override
   		public Connection getObject() throws Exception {
   			Class.forName(driver);
   			Connection conn =
   				DriverManager.getConnection(url,username,password);
   			return conn;
   		}

   		@Override
   		public boolean isSingleton() {
   			return false;
   		}

   		@Override
   		public Class<Connection> getObjectType() {
   			return Connection.class;
   		}
   		set/get
   		....
       }

       xml文件:
       <!--
       	因为这个类是一个工厂类,所以我们用名字conn在容器中拿对象的时候,
       	拿到并不是这个工厂类对象,而是这个工厂类对象调用完工厂方法后所返回的对象.
       	生产不同的产品
       -->
       <bean name="conn" class="com.briup.ioc.factory.ConnectionFactory">
       	<property name="driver">
       		<value>${driver}</value>
       	</property>

       	<property name="url">
       		<value>${url}</value>
       	</property>

       	<property name="username">
       		<value>${username}</value>
       	</property>

       	<property name="password">
       		<value>${password}</value>
       	</property>
       </bean>

       <!--
       	下面配置的这个类,可以自动的帮我们去读取指定的properties文件的
       	内容,文件中用key-value的形式存放数据,读完之后我们就可以用
       	${key}这种形式去拿文件中的value值了。
       	classpath指的是从src下面找.
       -->
       <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
       	<property name="location">
       		<value>classpath:oracle.properties</value>
       	</property>
       </bean>

       	driver=oracle.jdbc.driver.OracleDriver
   		url=jdbc:oracle:thin:@127.0.0.1:1521:XE
   		user=briup
   		password=briup
         main:
   		String path = "com/briup/ioc/factory/factory.xml";
   		ApplicationContext container =
   				new ClassPathXmlApplicationContext(path);
   		Connection conn = (Connection) container.getBean("conn");
   		System.out.println(conn);

      3) 通过实例工厂获得bean对象(不需要实现或者继承任何接口或者父类),默认单例
         注意spring中的PropertyPlaceholderConfigurer类的使用,在htmlsingle中直接搜索类名即可
         例如:一个普通的工程类
       public class ConnectionFactory{
   		private String driver;
   		private String url;
   		private String username;
   		private String password;

   		public Object getConnection() throws Exception {
   			Class.forName(driver);
   			Connection conn =
   				DriverManager.getConnection(url,username,password);
   			return conn;
   		}
   		get/set
   		....
         }

         xml文件:
   	<bean name="factory" class="com.briup.ioc.instanceFactory.ConnectionFactory">
   		<property name="driver">
   			<value>${driver}</value>
   		</property>

   		<property name="url">
   			<value>${url}</value>
   		</property>

   		<property name="username">
   			<value>${username}</value>
   		</property>

   		<property name="password">
   			<value>${password}</value>
   		</property>
   	</bean>

   	<!--
   		将来通过这个conn来拿对象,拿到的是名字为factory的工厂类调用完
   		名字为getConnection方法之后所返回的对象。默认单例。
   	-->
   	<bean name="conn" factory-bean="factory" factory-method="getConnection"></bean>

   	<!-- 读取properties文件 -->
       <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
   		<property name="location">
   			<value>classpath:oracle.properties</value>
   		</property>
   	</bean>

          main:
   		String path = "com/briup/ioc/instanceFactory/instanceFactory.xml";
   		ApplicationContext container =
   			new ClassPathXmlApplicationContext(path);
   		Connection conn = (Connection) container.getBean("conn");
   		System.out.println(conn);



    4) 通过静态工厂获得实例,默认单例
         例如:含义静态方法的工厂类
         public class ConnectionFactory{
   		private static String driver = "oracle.jdbc.driver.OracleDriver";
   		private static String url = "jdbc:oracle:thin:@127.0.0.1:1521:XE";
   		private static String username = "briup";
   		private static String password = "briup";

   		public static Object getConnection() throws Exception {
   			Class.forName(driver);
   			Connection conn =
   				DriverManager.getConnection(url,username,password);
   			return conn;
   		}
         }

         xml文件:
         <!-- 这样配置一定要求getConnection方法是静态方法，默认单例 -->
         <bean name="conn" class="com.briup.ioc.staticFactory.ConnectionFactory" factory-method="getConnection"></bean>

         main:
   		String path = "com/briup/ioc/staticFactory/staticFactory.xml";
   		ApplicationContext container =
   			new ClassPathXmlApplicationContext(path);
   		Connection conn = (Connection) container.getBean("conn");
   		System.out.println(conn);

11.自定义属性编辑器PropertyEditor
     Spring中我们可以使用属性编辑器来将特定的字符串转换为对象 :String-->object
     java.beans.PropertyEditor(JDK中的接口)用于将xml文件中字符串转换为特定的类型
     同时JDK为我们提供一个实现类java.beans.PropertyEditorSupport
     Spring在注入时,如果遇到类型不一致(例如需要Address类型但是用户传了个String)则会去调用相应的属性编辑器进行转换.
     spring会调用属性编辑器的setAsText(String str)进行处理用户传的字符串,并调用getValue()方法获取处理后得到的对象,所以我们在代码中处理完后记得调用setValue方法,要不然spring调用getValue方法拿不到你处理后的对象

     自定义属性编辑器示例：
         注意在配置文件中CustomEditorConfigurer类的使用,在htmlsingle中直接搜索类名即可
         //自定义编辑器类
         public class AddressEditor extends PropertyEditorSupport {

   		@Override
   		public String getAsText() {
   			return super.getAsText();
   		}

   		//Spring遇到数据类型不一致并且不能自己处理的时候会调用这个方法处理字符串
   		@Override
   		public void setAsText(String text) throws IllegalArgumentException {
   			String[] str = text.split(",");
   			String city = str[0];
   			String street = str[1];
   			String country = str[2];
   			Address add = new Address(city, street, country);
   			setValue(add);
   		}

         }

         //Address类
         public class Address {
   		private String city;
   		private String street;
   		private String country;
   		set/get
   		.....
         }

         //Student类
         public class Student {
   		private long id;
   		private String name;
   		private boolean gender;
   		private int age;
   		private Address address;
   		get/set
   		...
         }

         xml文件:
         <!-- 这个配置指明哪个类型对应哪个自定义编辑器 -->
         <bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
   		<property name="customEditors">
   			<map>
   				<entry key="com.briup.ioc.proEdit.Address"	value="com.briup.ioc.proEdit.AddressEditor"/>
   			</map>
   		</property>
         </bean>

         <!-- spring发现address的类型是Address的时候,就会调用对应的属性编辑器处理AddressEditor了 -->
         <bean id="student" class="com.briup.ioc.proEdit.Student">
   		<property name="id" value="1"/>
   		<property name="name" value="tom"/>
   		<property name="age" value="45"/>
   		<property name="gender" value="true"/>
   		<property name="address">
   			<value>kunshan,xueyuan,China</value>
   		</property>
        </bean>


12.自定义事件
     在spring中我们可以自定义事件,并且可以使用ApplicationContext类型对象(就是spring容器container)来发布这个事件,事件发布之后,所有的ApplicaitonListener(监听器)实例都会被触发并调用指定方法onApplicationEvent()来处理.
     例如:
     自定义事件类RainEvent:
     public class RainEvent extends ApplicationEvent {
   	public RainEvent(Object source) {
   		super(source);
   	}
     }

     监听器类RainListener1
     public class RainListener1 implements ApplicationListener {

   	public void onApplicationEvent(ApplicationEvent event) {
   		if (event instanceof RainEvent) {
   			System.out.println("唐僧大喊：" + event.getSource() + "赶快收衣服喽！");
   		}
   	}
     }
     监听器类RainListener2
     public class RainListener2 implements ApplicationListener {

   	public void onApplicationEvent(ApplicationEvent event) {
   		if (event instanceof RainEvent) {
   			System.out.println("我们：" + event.getSource() + "太好了不用上课了！");
   		}
   	}
     }

     xml文件:
     <!-- 只需要把这俩个监听器类交给spring容器管理就可以了 -->
     <bean class="com.briup.ioc.event.RainListener1"></bean>
     <bean class="com.briup.ioc.event.RainListener2"></bean>

     main:
     String path = "com/briup/ioc/event/event.xml";
     ApplicationContext container =
   		new ClassPathXmlApplicationContext(path);
     container.publishEvent(new RainEvent("下雨了！"));


13.ioc中的annotation配置

     @Autowired
     1 @Autowired默认按照byType匹配的方式进行注入,如果没有一个bean的类型是匹配的则会抛异常,如果有多个bean的类型都匹配成功了,那么再按byName方式进行选择
     2 @Autowired注解可以写在成员变量、setter方法、构造器函数上面
     3 @Autowired如果最终匹配不成功(注意一定是一个都没有找到的情况)则会抛出异常,但是如果设置为 @Autowired(required=false),则最终匹配不成功没有不会抛出异常。
     4 @Autowired可以结合 @Qualifier("beanName")来使用,则可以达到byName的效果
     5 @Autowired使用后需要在xml文件加入以下配置才能生效:
         <context:annotation-config/>


     @Resource
     1 @Resource的作用和 @Autowired差不多,只不过 @Resource是默认先用byName,如果找不到合适的就再用byType来注入
     2 @Resource有俩个属性,name和type,使用name属性则表示要byName匹配,使用type属性则表示要byType匹配
     3 @Resource使用后需要在xml文件加入以下配置才能生效:
         <context:annotation-config/>


     @PostConstruct 和 @PreDestroy
     1 标注了 @PostConstruct 注释的方法将在类实例化后调用。
     2 标注了 @PreDestroy 的方法将在类销毁之前调用。


     @Component
     1 @Component注解可以直接定义bean，而无需在xml定义。但是若两种定义同时存在，xml中的定义会覆盖类中注解的Bean定义。
     2 @Component注解直接写在类上面即可
     3 @Component有一个可选的参数，用于指定 bean 的名称: @Component("boss")
     4 @Component容易不指定参数，则 bean 的名称为当前类的类名小写
     5 @Component使用之后需要在xml文件配置一个标签: <context:component-scan/>
     6 <context:component-scan base-package="com.briup.ioc.annotation" /> 可以表示spring需要检查哪个包下的java类,看它们是否使用了 @Component注解
     7 @Component定义的bean默认情况下都是单例模式的,如果要让这个bean变为非单例,可以再结合这个 @Scope 注解来达到目标 @Scope("prototype")


     @Component是Spring中所有bean组件的通用形式, @Repository @Service @Controller 则是 @Component的细化,用来表示更具体的用例，分别对应了持久化层、服务层和表现层。但是至少到现在为止这个四种注解的实质区别很小(甚至几乎没有),都是把当前类注册为spring容器中的一个bean


     注意:
     component-scan标签默认情况下自动扫描指定路径下的包（含所有子包），将带有 @Component @Repository @Service @Controller标签的类自动注册到spring容器。对标记了 Spring中的 @Required @Autowired @PostConstruct @PreDestroy @Resource @WebServiceRef @EJB   @PersistenceContext @PersistenceUnit等注解的类进行对应的操作使注解生效（包含了annotation-config标签的作用）。


